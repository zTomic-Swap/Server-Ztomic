/**
 * @module @zk-kit/utils
 * @version 0.6.0
 * @file Essential zero-knowledge utility library for JavaScript developers.
 * @copyright Ethereum Foundation 2024
 * @license MIT
 * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}
*/
'use strict';

var scalar = require('./scalar.cjs');

/**
 * @class F1Field
 * Represents a finite field of order 'order' providing arithmetic operations under modulus.
 * This class includes operations such as addition, subtraction, multiplication, division,
 * and inversion, all performed modulo the field's order. It's designed to work with bigints,
 * supporting large numbers for cryptographic purposes and other applications requiring
 * modular arithmetic.
 *
 * @property one Represents the scalar value 1 in the field.
 * @property zero Represents the scalar value 0 in the field.
 * @property _order The order of the finite field (i.e., the modulus).
 * @property _half Half the order of the field, used for certain comparisons.
 * @property _negone The scalar value -1 in the field, represented positively.
 */
class F1Field {
    constructor(order) {
        this.one = BigInt(1);
        this.zero = BigInt(0);
        this._order = order;
        this._half = order >> this.one;
        this._negone = this._order - this.one;
    }
    /**
     * Ensures a given result falls within the field by applying modular reduction.
     * This method also handles negative inputs, correctly mapping them into the field.
     * @param res The result to be normalized to the field.
     * @returns The equivalent value within the field.
     */
    e(res) {
        if (res < 0) {
            let nres = -res;
            if (nres >= this._order) {
                nres %= this._order;
            }
            return this._order - nres;
        }
        return res >= this._order ? res % this._order : res;
    }
    /**
     * Performs modular multiplication of two bigint values within the field.
     * @param a The first value.
     * @param b The second value.
     * @returns The product of 'a' and 'b' modulo the field's order.
     */
    mul(a, b) {
        return (a * b) % this._order;
    }
    /**
     * Subtracts one bigint from another under modulus, ensuring the result is within the field.
     * @param a The value from which to subtract.
     * @param b The value to be subtracted.
     * @returns The difference of 'a' and 'b' modulo the field's order.
     */
    sub(a, b) {
        return a >= b ? a - b : this._order - b + a;
    }
    /**
     * Adds two bigint values together under modulus, ensuring the result is within the field.
     * @param a The first value.
     * @param b The second value.
     * @returns The sum of 'a' and 'b' modulo the field's order.
     */
    add(a, b) {
        const res = a + b;
        return res >= this._order ? res - this._order : res;
    }
    /**
     * Computes the multiplicative inverse of a given value within the field.
     * This method uses the Extended Euclidean Algorithm to find the inverse,
     * ensuring the result is always a positive value less than the field's order.
     * If the input value is zero, which has no inverse, an error is thrown.
     * @param a The value for which to compute the inverse.
     * @returns The multiplicative inverse of 'a' modulo the field's order.
     * @throws if 'a' is zero.
     */
    inv(a) {
        let t = this.zero;
        let r = this._order;
        let newt = this.one;
        let newr = a % this._order;
        while (newr) {
            const q = r / newr;
            [t, newt] = [newt, t - q * newt];
            [r, newr] = [newr, r - q * newr];
        }
        if (t < this.zero) {
            t += this._order;
        }
        return t;
    }
    /**
     * Divides one bigint by another within the field by multiplying the first value
     * by the multiplicative inverse of the second.
     * @param a The dividend.
     * @param b The divisor.
     * @returns The result of the division of 'a' by 'b' modulo the field's order.
     */
    div(a, b) {
        return this.mul(a, this.inv(b));
    }
    /**
     * Checks if two bigint values are equal within the context of the field.
     * @param a The first value to compare.
     * @param b The second value to compare.
     * @returns True if 'a' equals 'b', false otherwise.
     */
    eq(a, b) {
        return a === b;
    }
    /**
     * Squares a bigint value within the field.
     * This is a specific case of multiplication where the value is multiplied by itself,
     * optimized for performance where applicable.
     * @param a The value to square.
     * @returns The square of 'a' modulo the field's order.
     */
    square(a) {
        return (a * a) % this._order;
    }
    /**
     * Compares two bigint values to determine if the first is less than the second,
     * taking into account the field's order for modular comparison.
     * @param a The first value to compare.
     * @param b The second value to compare.
     * @returns True if 'a' is less than 'b', false otherwise.
     */
    lt(a, b) {
        const aa = a > this._half ? a - this._order : a;
        const bb = b > this._half ? b - this._order : b;
        return aa < bb;
    }
    /**
     * Compares two bigint values to determine if the first is greater than or equal to the second,
     * considering the field's modular context.
     * @param a The first value to compare.
     * @param b The second value to compare.
     * @returns True if 'a' is greater than or equal to 'b', false otherwise.
     */
    geq(a, b) {
        const aa = a > this._half ? a - this._order : a;
        const bb = b > this._half ? b - this._order : b;
        return aa >= bb;
    }
    /**
     * Computes the negation of a bigint value within the field.
     * The result is the modular additive inverse that, when added to the original value,
     * yields zero in the field's modulus.
     * @param a The value to negate.
     * @returns The negation of 'a' modulo the field's order.
     */
    neg(a) {
        return a ? this._order - a : a;
    }
    /**
     * Checks if a bigint value is zero within the context of the field.
     * @param a The value to check.
     * @returns True if 'a' is zero, false otherwise.
     */
    isZero(a) {
        return a === this.zero;
    }
    /**
     * Raises a base to an exponent within the field, efficiently computing
     * scalar exponentiation using the square-and-multiply algorithm.
     * Supports both positive and negative exponents through the use of the `inv` method for negatives.
     * @param base The base to be exponentiated.
     * @param e The exponent.
     * @returns The result of raising 'base' to the power 'e' modulo the field's order.
     */
    pow(base, e) {
        if (scalar.isZero(e)) {
            return this.one;
        }
        const n = scalar.bits(e);
        if (n.length === 0) {
            return this.one;
        }
        let res = base;
        for (let i = n.length - 2; i >= 0; i -= 1) {
            res = this.square(res);
            if (n[i]) {
                res = this.mul(res, base);
            }
        }
        return res;
    }
}

module.exports = F1Field;
